#  网页的组成（3部分）
* 结构层（html语法）


* 表现层（css）


* 行为层(js)

#流程   整个事件的过程
#需求
#程序   记录的媒介


#程序？	
	为了实现某个功能或者某个目的，通过计算机语言写的指令序列的集合。


#JavaScript Java
* 公司：java-sun    JS-网景公司


* 语言：java是强类型的语言，JS是弱类型的语言

  ​   init a =10;            var a = 10;var a =10.3;
  ​       float b =123;          
  ​   string c ='add';       var a = 'ddd';

* java是纯面向对象的（封装、继承、多态）

​        JS是基于对象（内置对象：日期Data，数组...）

* 执行：java是编译类型的；JS是解释型的


#JS作用
* 实现动效


* 数据验证


* 操作html/css


* 制作游戏


* 单页面应用（谷歌在线的word、excel等编辑器；各大平台的云）


* 服务器端的应用（node.js）


* cookie

#JS是什么
JS是一个脚本语言（可以直接在浏览器中解析执行，无需编译）。
JS是基于对象和事件驱动的解释性的松散型语言。

  * 基于对象
  
  
  * 事件驱动：对浏览器和用户的行为进行响应
  
  
  * 解释型


  * 松散型；弱类型

# JS语言
  * 如何执行
  
  
  * html如何引入JS
    * 1、引入外部文件：<script src=""></script>    
        注意：引入外部文件的时候，不要在标签内部写内容   
    * 2、嵌入式：<script> console.log('');</script>
    * 3、在超链接或者重定向里边去写入<a href=''>超链接</a>
  
      `<a href="javascript:vioid(0)">不链接</a>` 
      * 超链接的表现形式：
        * 普通链接
        * 写入js代码，会屏蔽href属性
        * 资源下载，默认只能是压缩过的文件
        * 空链接，实现的是返回页面顶部
        * 重定向`<from action="javascript:alert('1')"></from>`
    * 4、在事件后调用
        `<div onclick="alert(1)">点击我</div>`
  * 多个script块之间会相互影响
  * 如何输出？
  * JS的输出工具
    1、alert():
      在页面弹出一个框
      注意：alert会阻止后面代码的运行
    2、console.log()
      将数据输出至控制台
    3、document.write('<div>html</div>')
      将数据内容输出到页面中
      注意：识别标签和行内样式
    4、confirm()
      在页面中弹出一个带确定和取消按钮的弹出框
    5、prompt('请输入你的姓名')
      页面弹出一个带提示信息和输入框的弹出框
  * 把想要展示的数据输出至页面
  * 调试

#变量
  * 一、命名规范：
    * 1.变量名必须以字母、下划线_或开头，后面部分可以跟任意的字母、数字、或$；
    * 2.不能使用关键字（JS自定义的var）或者是保留字（为以后扩展用）命名
    * 3.JavaScrpit有自己的命名习惯
      * 驼峰命名法：getElementByld
      * 首字母大写法：Object
    * 4.变量名区分大小写
    * 5.命名一定要有意义，提高代码可读性
  * 二、什么是变量？
    * 1.变量是保存数据的容器。
         注意：内存就是一个盒子，每次声明一个变量，它都会在内存中开辟一段空间进行保存。保存起来后，当我们需要用的时候会从内存中获取相应的数据。如果浏览器关闭，内存会释放空间，方便下次使用。
    * 2.变量声明（通过关键字）
      ​    var
      ​    let(es6)
             * let的用法类似于var
             * let不存在变量提升现象
             * let不能重新声明，报错改变量已经存在
             * let存在块级急作用域
      ​    const(es6)
             const声明的是一个常量
             const只能声明的同时进行赋值
             const也不存在变量提升现象
             const不能重新声明。报错改变量已存在

    * 3.变量的赋值情况
           声明的同时进行赋值
           声明之后进行赋值
           声明多个变量并同时进行赋值
           注意：多个变量之间用逗号隔开
           声明多个变量，之后进行赋值
    * 4.注意：
           变量声明之前进行调用，会返回undefined（未赋值）。
           不通过关键字声明的变量，但是赋值了，他会返回对应的值（全局变量）。
           不通过关键字声明的变量，但是没有赋值，他会报错。
           对变量重新赋值，会发生覆盖。
           对变量重新声明并赋值，会发生覆盖。
#数据类型
  * 一、数据类型？
    能够表达或者操作值得类型，称为数据类型。
  * 二、为何要划分数据类型？
    * 需求
    * 在内存中存储的位置不一样
  * 三、数据类型（两大类）
    * 初始类型（存放在栈区，内存比较小，访问速度快）
      * undefined
          声明变量并未赋值，返回ubdefined；
          声明变量之前进行访问，返回undefined；
          返回的值：undefined
      * null(空，占位符)
          可能的值：null
          返回值得类型：object
      * numeber(数值类型)
         可能的值：整型，浮点型，二进制()、十进制、科学计数法(最大值和最小值);
         返回的值：对应的值
         返回值得类型：number
      * string(字符串类型)
         通过引号引起来的
         返回的值：对应的字符串
         返回值得类型：string
      * boolean(布尔类型)
        true flash
        返回的值：true flash
        返回值得类型：boolean
      * symbol(es6)
  * 引用类型（存放在堆区，内存较大，访问速度较慢）
      object(数组，函数...)

# 运算符
  * 一、算数运算符（+ - * / % ++ --）
  * +：进行加法运算
    * 如果两个操作数都是number类型，最终得到number的值
    * 如果其中一个操作数是undedined，最终得到NaN(not a number,是number类型的一个状态)
    * 如果有一个操作数是null，最终得到number的值
    * 如果有一个操作数是bollean，会转换成对应的值进行计算。
         var num1 = 30;
       var num2 = 20;
       console.log(num1 + num2);
      * 字符串连接
        * 如果操作数有一个是string
  * -：减法运算符
    * 如果两个操作数都是number类型，最终得到number的值
    * 如果其中一个操作数是undedined，最终得到NaN
    * 如果有一个操作数是null，最终得到number的值
    * 如果有一个操作数是bollean，会转换成对应的值进行计算。
    * 如果操作数有一个是string
      * 数值      隐式转换
      * 字母      NaN
      * 如果两个操作数都是string，得到NaN
  * *:乘法运算符
       特殊用法： ** 进行幂运算
  * ++：自增  num++ 先运行再自增1   /   ++num 先自增1再运行
  * --：自减  num-- 先运行再自减1   /   --num 先自减1再运行
* 二、比较运算符（关系运算符）  （ > < == === >= <= !=）
  * 如果操作数是字符串类型的，会先进行隐士转换，转换成功进行正常运算，转换不成功，永远返回false；
  * null == 0; false
  * null == undedined; true
      null === undedined; flase
* 三、赋值运算符(= += -= *= /= %=)
* 四、逻辑运算符(&& 与 ||或  !非)
    可以操作任何类型的数据。
    数字0，false,undefined,null,NaN,空字符串会转换为false


* &&  同真为真，其余全为假

  | num1  | num2  | result |  结果  |
  | :---: | ----- | ------ | :--: |
  | true  | true  | true   | num2 |
  | true  | false | false  | num2 |
  | false | true  | false  | num1 |
  | false | false | false  | num1 |

    如果第一个操作数为假，发生短路原则，对第二个数不会进行操作，并返回假值


* ||  同假为假，其余全为真

  | num1  |  um2  | result |  结果  |
  | :---: | :---: | :----: | :--: |
  | false | false | false  | num2 |
  | false | true  |  true  | num2 |
  | true  | false |  true  | num1 |
  | true  | true  |  true  | num1 |


   如果第一个操作数为真，发生短路原则，对第二个数不会进行操作，并返回真值
* 五、其他运算符
  * 1.一元运算符
    * new
    * typeof
         ++ --
         +（正号）  -(负号)
         delete(删除一个对象)
  * 2.三元运算符
       条件表达式?为真的值：为假的值
* 六、特殊运算符()   (3+5)*2
      作用：提高优先级
* 七、模板字符串   (es6)
      方便引入变量``（反引号）
      模板字符串要用反引号引起来，如果需要引入变量通过${变量名}
      console.log(`这是num1 -- ${num1}和num2 -- ${num2}的和${sum}`);

# 流程控制
  * 一、流程
   程序代码的执行顺序。
   注意：JS的执行是根据浏览器的解析从上到下，一条语句一条语句的执行，有且只有这一种方式。
* 二、流程控制
   通过规定的语句让程序代码有条件的按照一定的方式执行。
* 三、表达式
   表达式一般有运算符和操作数构成，且有一定的值。
* 四、语句
   以;为标识的一条语句。
  * 声明语句（声明一个变量、数组.....）
    * 赋值语句（ 对变量进行赋值）
    * if语句 switch语句 for语句
    * 函数  
* 五、三大流程控制
    1.顺序结构
      是程序中最基本的流程控制，默认从上到下，一条语句执行。
    2.选择结构
  * 分支结构
          if(条件){执行语句}else{}
          if(){}else if(){}else{}
          注意：条件可以是表达式也可以是任何数据类型
  * 条件结构
        switch(表达式){
        case 条件1：条件一成立执行的语句。
        break;
        case 条件2：条件二成立执行的语句。
        break;
        case 条件3：条件三成立执行的语句。
        break;
        ...
        default:alter("有误");
         }
  * 循环结构
    当在条件满足的时候，需要重复的执行一段代码。
    * for
      * for（初始化变量;条件表达式;步操作）{
         执行的语句;
         } 
      * for in(es6) [一般用于数组和对象的遍历]
         for(变量 in 对象){

         }

         for in最终遍历出来的是对象的属性

    * while语句
        while(条件表达式){
           要执行的操作;
        }
    * do while语句
      do{

      }while(){

      }


      总结：
      while和do while的区别：
       * while：满足条件才执行循环体；
       * do while：先执行一次循环体，在进行判断；
    
      for和while
       * 循环次数确定时用for
       * 循环次数不确定时用while
    
      终止语句
       * break:跳出整个循环（一层）
       * continue:跳出本层循环
        注意：最好用适当的语句替代continue语句
       * 一次跳出多层循环:在要跳出的那层循环前面加一个标记，比如：'out:'，那么终止语句就是'break out;'

# 数组
  * 一、数组
  * 变量：存储数据的容器
  * 数组：存储多条数据的容器/存储一组或者一系列相关数据的集合

* 二、优势？
  * 方便对数据进行管理
  * 可以保存大批量的数据

* 三、创建方式
  * 1、json格式

    var arr[]

       注意：

    - 数组默认值为空[变量默认值是undefined]
      - 数组的长度是可变的
      - 数组可以保存任何类型的数据
      - 数组的下标是从0开始

  * 通过实例化对象的方式：

    var arr = new Array();

    ​

* 四、赋值情况
  * 声明的同时进行赋值
        var arr = [34,65,78,'aaa','cc']
    * 声明之后进行赋值
        var arr1 =[];
        arr1 [0] = 34;
        arr1 [1] = 65;
        arr1 [2] = 78;

* 五、对数组的访问

   以下标的形式进行访问

  - length属性：统计数组的长度

    - 访问数组的第一个元素：arr[0]
    - 访问数组的最后一个元素：arr[arr.length-1]
    - 当访问的下标超出数组长度，则返回undefined；

  - 遍历

    for(let i = 0;i<var2.length;i++)

    for (let i in arr){

    ​       arr2[i];

    }
* 六、二维数组
    二维数组：每个数组元素的值，对应的又是一个数组
    * 二维数组的访问方式：
         * 通过双下标
    * 二维数组的遍历：双层for循环
* 七、浅拷贝和深拷贝
    浅拷贝：赋值，会改变。指向的是赋值对象所有引用对象的全部赋值。
    深地址：传值,不会改变。指向的是赋值对象所有引用对象的引用。

#函数
* 一、函数：
   函数就是将能够实现某一特定功能的代码块封装起来，方便重复调用。

* 二、特点：
   程序会更加简洁，维护起来更容易。

* 三、函数声明（三种方式）
   1.通过关键字
    function 函数名([参数1],[参数2],[参数3]...){
      函数体
    }
   2.通过字面量的方式
  ​ var 变量名 = function([参数1],[参数2],[参数3]...){
  ​   函数体
  ​ }
   3.通过实例化对象的方式
    var 变量名 = new Function();

* 四、函数调用
   1.函数名/变量名 + ()
   2.函数自调用
    注意：函数自调用的时候，无论之前是什么，必须加分号。
   3.在事件之后调用
    只需要写函数名

* 五、注意
  * 函数名重复会发生覆盖
  * 函数自调用时加分号;
  * 通过关键字声明的函数，可以在声明之前进行访问;通过自变量声明的函数，只有在解析到它的时候，才会进行赋值
  * 代码是从上到下一条语句一条语句解析执行的，多个script块由于解析环境一样，他们之间会相互影响，调用不同块
      之间函数需要注意一定要先声明。

* 六、参数：动态改变函数体内相对应的型与值，使统一函数体呈现不同效果。
    形参：声明函数时()里传的是参数
    实参：调用函数时()里传的是参数

* 七、有关参数个数
  * 实参和形参一一对应
  * 实参个数 < 形参：多余的形参返回undefined
  * 实参个数 > 形参：只返回形参相对应的值

* 八、多余实参的接收
   1、reset参数
    reset接收剩余参数的时候，作为一个数组进行处理。

    注意：...reset是一个运算符
      eg:function al(num1,num2,...reset){
        console.log(num1,num2,reset);
      }
   2、 arguments 对象
    当我们创建一个函数时，他默认会创建一个arguments对象。
    在arguments对象身上，保存了所有参数信息
      eg:function a1(num1,num2){
          console.log(num1,num2,arguments[2],arguments[3],arguments[4]);
        }
        a1(1,2,3,4,6)


    argunments.callee指向函数自身

* 九、默认参数
  1.直接在形参后进行设置
  ​ 注意：默认参数位置一定放在最后
  2.通过三元运算符
  ​ 条件表达式?为真的值:为假的值
  3.逻辑或 ||

* 十、函数返回值
  return
  * 在函数调用的地方，返回一个值
    注意：
    * 如果return后没有值，返回undefined;
      ​   return只能返回一个值，如果在return'后跟多个值，会发生覆盖，最终返回最后一个值。
  * 终止函数执行，return之后的语句都将不再执行。
  * return语句可以有多条语句，但它执行一条。

* 十一、作用域
  ​ 环境：
  ​   宿主环境：浏览器
  ​   执行环境：决定了变量和函数的访问权限
  ​     全局环境
  ​     函数环境
  ​ 作用域：有关变量和函数的访问范围
  ​ 作用域中分全局作用域和局部作用域
  ​ 全局作用域：在任何地方都可以访问的变量
  * 在函数外部声明的变量

    * 没有通过关键字声明的变量，并且同时赋值
  * window对象，window.name,window.top
                  
    局部作用域：在规定的代码块内能够访问的变量

    块级作用域：(es6)if switch function for

    作用域链：作用域链的存在造成了闭包函数的产生

* 十二、闭包

  闭包函数的作用：
    * 保存局部变量；
    * 在函数外部访问局部变量。

  闭包函数：在函数中存在作用域链，函数中的变量全部都保存在作用域链中，这样的特性我们成为闭包。

* 十三、回调函数
  把一个函数的指针(直接写函数名);
  作为参数传递给另一个函数，这个函数就叫回调函数。(只返回一个值，所以可以作为参数)

  * 传参方式

     1.通过函数的指针
     2.把整个函数传进去

* 十四、 递归函数
  在函数内部直接调用自己或者简介调用自己


    阶乘  n! = n * (n-1)!
    0! = 1
    1! = 1
    2! = 2 * 1 
    3! = 3 * 2 * 1
    4! = 4 * 3 * 2 * 1


* 十五、函数重载
  * 函数重载
    * 同一个函数因为传入的参数的类型或个数不同，可以对应多个函数的实现，而且每种实现对应一个函数体。
    * 重载函数常用来实现功能类似而所处理的数据类型不同的问题。

* 十六、预解析顺序
   1.按照<script></script>来解析，有多个<script></script>对时，按块解析，先解析第一个<script></script>  中的代码。
   2.按环境解析
   3.遇到关键字var和function时（即以关键字创建的函数），提前解析到内存中（相对应的环境里）。即可在声明前调用。
   4.若还有<script></script>，再按照上面的顺序进行解析。


# 对象
面向过程：按照流程一步一步操作
面向对象：不管中间环节如何实现，只要结果
* 一、对象：一切皆对象
  对象指的就是人们所能接触到的所有的识物，有抽象的，也有具体的。

  对象是属性和行为的集合.
  ​ 属性：描述对象特征的数据
  ​ 行为：操作对象方法的数据

​ 类：具有相同属性和行为的对象的抽象。
​   类是对象的抽象；
​   对象是类的实例化

* 二、声明一个对象
  * 1.实例化
    var person = new object();
  * 2.字面量
    var person1 = {};
  * 3.构造函数(函数名首字母大写)
    fubction Person(){

    }
    var lisi = new Person();
* 三、添加属性、方法
  属性： 对象.属性名 = 属性值
  ​   对象['属性名'] = 属性值
  方法： 对象名.方法名 = function(){}
  ​   对象名['方法名'] = function(){}
* 四、访问属性、方法
  属性：对象.属性名;
  ​   对象['属性名']；
  方法：对象.方法名();
  ​   对象['方法名'']();
* 五、删除属性、方法
  delete
* 六、清空对象
  null
* 七、for in
  对象：   i  ->  属性名/方法名
  ​   对象名[i] -> 属性值/方法

  数组：  i ->   下标
  ​   数组名[i] ->  数组元素


* 对象封装：
  将对象的所有组成部分全部组合起来，并对部分细节进行隐蔽，使其受到保护，只留下和外界的接口

   * 一、工厂函数
    不推荐。方便维护，节省内存。但是代码不规范
   * 二、构造函数
    造成内存浪费
   * 三、原型
      原型也是一个对象。在JS中，每一对象都会继承另一个对象所有的属性和方法，被继承的这个对象就是原型。

      1、对象:[[prototype]]
      [[prototype]]是对象内部的一个属性，但是我们不能直接访问。FF和Chrome提供了'proto'访问器，ECM提供了Object.

      getPrototype(Object)访问器              指向该对象的原型


      2、函数：每个函数都有一个pototype属性   保存的是该函数的原型对象

      当一个函数作为构造函数使用时，他会把该函数的prototype属性作为原型赋值给所有通过该函数实例化的对象的原型。


      3、 原型对象：construcyt                指向的是实例的构造函数


      函数对象和原型对象通过prototype和constructor实现相互关联
      通过prototype可以实现代码共享，实现继承


   * 四、构造函数结合原型
    构造函数中一般放属性
    原型中一般放方法